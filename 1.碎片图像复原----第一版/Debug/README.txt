项目介绍:
    本项目主要分为 Main, Package, Test 三个模块
    Main: 主模块
        MainUI.py 为UI界面版的主程序，集成了包模块的所有功能
        包括下载，切分，复原，生成数据集，测试数据集等功能，并通过一个UI交互界面展示
    Package: 包模块
        Config.py 用于配置文件路径以及算法参数
        LoadFigure.py 用于下载数据图像
        SplitFigure.py 用于随机切分图像
        RecoverFigure.py 用于复原碎片图像
        本模块主要为 Main 主模块提供相关功能的调用
    Test: 测试模块
        CreateFigures.py 用于产生图像数据集
        ComputeAccuracy 通过测试集计算算法准确率
        Test.py 对包模块中关键函数功能的测试
        本模块确保包模块代码的正确性，并未Main模块开发提供借鉴


功能介绍:
    1. 从本地选择图片或者中网上爬取图片，并随机均匀切分成M行N列的小矩形碎片，总共M*N张。
        碎片文件以png格式保存在 Data/SplitFigures/Sample 下, 其中 cat.jpg 为原图像
    2. 通过算法将碎片图像复原，复原后的新图像保存至 Data/RecoverFigures/sample.jpg
    3. 批量从网上下载数据集，对每一个数据集生成一堆碎片，然后再还原这些碎片得到新图片，
        将新图片与原图片比较，从而计算得到总准确率，作为该算法的衡量指标
    结果:
        为了方便UI程序的设计，本程序设定使用 M = 4， N = 4, 可以得到准确率在 92% 左右
        通过笔者测试，该算法在 1 < M, M < 8 情况下表现良好, 准确率均在 80% 以上
        当 1 < M, M < 5 的情况下，准确率基本在 90% 以上


算法介绍
    假设切分为 M*N 总共 X 张碎片图像， 具体算法请看 ImgRecover 类中的 _jointImg()
    1. 首先设定一个最大迭代次数 K ，初始化 X 张碎片为 X 个顶点
    2. 随机从 X 个碎片中选取一张碎片1，这张碎片1的上下左右四个方向，每个方向与其它 N-1 张碎片计算
        边缘图像矩阵的欧式距离，从这4*(X-1)个距离里面选取一个最小值对应的碎片2和方向，
        并以该方向连接碎片1和碎片2, 算时不考虑前面已经计算过的点，然后从这 X 张剔除碎片1,
        并且迭代次数减1， 若跌代次数小于0时，则无解，该算法终止。
    3. 重复步骤2， 直到 X 张碎片全部被剔除， 最后这X个顶点碎片将会构成一张图
    4. 对这个碎片图进行深度优先遍历，判断是否能遍历所有X个顶点，即这个图是否连通，如果不连通，
        返回进行步骤2，如果连通，继续进行步骤5 。
    5. 判断这个图形状是否是一个M*N的矩形。我们在遍历的时候，规定起始点坐标为（0，0），
        右为x轴正方向，下为y轴正方向，向右x加1，向下y加1, 反向向减1， 找出x最小和最大的值，
        看两个值的差是否为M，y值同理，若也为N，则继续进行步骤6，否则进行步骤2。
    6. 将所有碎片顶点的坐标 (x, y) 以字典序进行排序，依次从左到右从上到下进行拼接
        从而得到复原后的图像，并保存

    分析可知，该算法属于贪心类算法和随机算法，因为每次迭代都是随机的，所以每次都会给出一个局部最优解，
        不断的淘汰这些局部解，最终就会得到一个最终的全局最优解，不过也会有一定的概率超过迭代次数后
        依旧没有出现全局最优解，这个概率事实证明很小。
    时间复杂度：O(X^2)
        每个点要计算4*(X-1)次，一共有X个点，因此算法复杂度为O(X^2)


作者介绍:
    笔名： PyJun
    邮箱： py.jun@qq.com
